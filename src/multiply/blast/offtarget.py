import pandas as pd
from collections import namedtuple
from dataclasses import dataclass


@dataclass(eq=True)
class Position:
    chrom: str
    start: int


class AmpliconFinder:
    def __init__(self, bound_df):
        """
        Find all potential amplicons between a list of
        primer binding sites, generated by BLAST

        TODO:
        - Off-by-one differences in BLAST / primer3
        - Identify all "on-target" amplicons
            - Plus "cross-amplicons"; e.g. v0 x v1
            - Ensure these are *all* present (or almost all, within size)
            - Caution: might be future use cases where people BLAST against host genomes
        - Remove the above, remainder is off-target
        - Produce a matrix, but needs to be correctly order, with all primers

        """

        # Save inputs
        self.bound_df = bound_df

        # Generated
        self.amplicon_df = None
        self.ontarget_df = None
        self.offtarget_df = None

    def find_amplicons(self, max_size_bp=6000):
        """
        TODO:
        - Off-by-one differences between primer positions and amplicons

        """

        # Storage -- can make flexible
        Amplicon = namedtuple(
            "Amplicon",
            [
                "chrom",
                "F_target",
                "R_target",
                "F_primer",
                "R_primer",
                "F_start",
                "R_start",
                "product_bp",
            ],
        )

        # Iterate and find amplicons
        amplicons = []
        for chrom, chrom_df in self.bound_df.groupby("sseqid"):
            for _, F_df in chrom_df.query("sstrand == 'plus'").iterrows():

                # Get start position of the forward primer
                # 5' position
                F_start = int(F_df["sstart"])

                # Get proximal reverse primers, if they exist
                # - Very important to get directionality of query correct
                R_df = chrom_df.query(
                    "sstrand == 'minus' and 0 < (sstart - @F_start) < @max_size_bp"
                )

                # Check for any pairs
                if R_df.shape[0] > 0:
                    F_amplicons = [
                        Amplicon(
                            chrom=chrom,
                            F_target=F_df["qseqid"].split("_")[0],
                            R_target=row["qseqid"].split("_")[0],
                            F_primer=F_df["qseqid"],
                            R_primer=row["qseqid"],
                            F_start=F_start,
                            R_start=row["sstart"],
                            product_bp=row["sstart"] - F_start,
                        )
                        for _, row in R_df.iterrows()
                    ]
                    amplicons.extend(F_amplicons)

        # Store
        self.amplicon_df = pd.DataFrame(amplicons)

    def _get_expected_dict(self, primer_df):
        """
        Build a dictionary containing expected binding
        positions

        """
        return {
            row["primer_name"]: Position(chrom=row["chrom"], start=row["start"] + 1)
            for _, row in primer_df.iterrows()
        }

    def _annotate_expected_binding(self, expected_dt):
        """
        Annotate `self.amplicon_df` with expected binding sites

        """
        self.amplicon_df.insert(
            self.amplicon_df.shape[1],
            "F_expected",
            self.amplicon_df.apply(
                lambda r: Position(chrom=r["chrom"], start=r["F_start"])
                == expected_dt[r["F_primer"]],
                axis=1,
            ),
        )
        self.amplicon_df.insert(
            self.amplicon_df.shape[1],
            "R_expected",
            self.amplicon_df.apply(
                lambda r: Position(chrom=r["chrom"], start=r["R_start"])
                == expected_dt[r["R_primer"]],
                axis=1,
            ),
        )

    def create_ontarget_dataframe(self, primer_df):
        """
        Create an ontarget dataframe
        """
        expected_dt = self._get_expected_dict(primer_df)
        self._annotate_expected_binding(expected_dt)
        self.ontarget_df = self.amplicon_df.query("F_expected and R_expected")

    def create_offtarget_dataframe(self):
        """Create an offtarget dataframe"""
        self.offtarget_df = self.amplicon_df.query("not (F_expected and R_expected)")
